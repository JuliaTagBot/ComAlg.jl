import Base: show

export vector_space, ModField, ModFieldElem, ModFieldToModFieldMor, free_module


mutable struct MPolyIdlSet{T <: MPolyElem{ <: RingElem}}
  R::MPolyRing{T}
  function MPolyIdlSet{T}(R::MPolyRing{T}) where T
    return new(R)
  end
end

function show(io::IO, I::MPolyIdlSet)
  println(io, "Set of ideals of $(I.R)\n")
end

mutable struct MPolyIdl{T <: MPolyElem{ <:RingElem}}
  gens::Array{T, 1} # initial generators
  parent::MPolyRing{T}
  std::Array{T, 1} # a Groebner basis is known/ computed
  ishomogenous::Bool
  hilbert::Any #PowerSeries

  function MPolyIdl{T}(gens::Array{T, 1}) where T
    r = new()
    r.gens = gens
    return r
  end
end

function show(io::IO, I::MPolyIdl)
  println(io, "ideal in $(I.parent.R), generated by $(I.gens)\n")
end


######################################################################
mutable struct ModField{T <: Nemo.FieldElem}
  ring::Nemo.Field
  dim::Int

  function ModField{T}(R, n::Int) where T <: Nemo.FieldElem
    r = new()
    r.ring = R
    r.dim = n
    return r
  end
end


function vector_space(K::Nemo.Field, n::Int, t::Type=elem_type(K))
  return ModField{t}(K, n)
end

function free_module(K::Nemo.Field, n::Int)
  return vector_space(K, n)
end

function show{T}(io::IO, M::ModField{T})
  print(io, "free module of rank $(M.dim) over $(M.ring)\n")
end

mutable struct ModFieldElem{T <: Nemo.FieldElem}
  coeff::Array{T, 1} # TODO: figure out how to declare a matrix...
  parent::ModField{T}

  function ModFieldElem{T}(M::ModField{T}, c::Array{T, 1}) where T <: Nemo.FieldElem
    r = new()
    r.parent = M
    r.coeff = c
    return r
  end
end

function (V::ModField{T})(c::Array{T, 1}) where T <: Nemo.FieldElem
  v = ModFieldElem{T}(V, c)
end

function show(io::IO, x::ModFieldElem)
  print(io, "vector: ", x.coeff)
end

mutable struct ModFieldToModFieldMor{T <: Nemo.FieldElem} <: Map{ModField, ModField}
  header::Hecke.MapHeader
  map::MatElem{T}

  function ModFieldToModFieldMor{T}(M::ModField{T}, N::ModField{T}, map::MatElem{T}) where T
    r = new()
    function image(x::ModFieldElem)
      return N(map*Nemo.matrix(coeff_field(M), dim(M), 1, x.coeff))
    end
    r.header = Hecke.MapHeader(M, N, image)
    r.map = map
    return r
  end
end


#############################################################
# same again for Euc, ModDed
# and
# Subquo....
mutable struct ModSub{T <: RingElem}
  gen::MatElem{T} # meant to be in R^n as the module generated by the rows of gen
  isGB::Bool
  gen_gb::MatElem{T}

#  gen_gb_sing :: smodule
end

function Base.show(io::IO, S::ModSub)
  println(io, "sub-module, generated by\n")
  for i=1:rows(S.gen)
    println(io, "  g[$i] = ", sub(S.gen, i:i, 1:cols(S.gen)))
  end
end

mutable struct ModSubLazy{T <: RingElem}
  #the intersection of A and B, but not (yet) computed.
  A::ModSub{T}
  B::ModSub{T}
end

function Base.show(io::IO, S::ModSubLazy)
  println(io, "intersection of")
  println(io, A)
  println(io, "and")
  println(io, B)
end

mutable struct ModSubQuo{T <: RingElem} # an Mpoly ring? quotient thereof?
  num::ModSub{T}
  den::Union{ModSub{T}, ModSubLazy{T}}
end

function Base.show(io::IO, M::ModSubQuo)
  print(io, "general sub-quotient with $(rows(M.num.gen)) generators")
  if isdefined(M, :den)
    print(io, " and some known relations\n")
  else
    print(io, "\n")
  end
end

