mutable struct MPolyIdlSet{T} where T <: MPolyElem{ <: RingElem}
  R::MPolyRing{T}
  function MPolyIdlSet{T}(R::MPolyRing{T})
    return new(R)
  end
end

function show(io::IO, I::MPolyIdlSet)
  println(io, "Set of ideals of $(I.R)\n")
end

mutable struct MPolyIdl{T} where T <: MPolyElem{<:RingElem} #Field?
  gens::Array{T, 1} # initial generators
  parent::MPolyRing{T}
  std::Array{T, 1} # a Groebner basis is known/ computed
  ishomogenous::Bool
  hilbert::Any #PowerSeries

  function MPolyIdl{T}(gens::Array{T, 1})
    r = new()
    r.gens = gens
    return r
  end
end

function show(io::IO, I::MPolyIdl)
  println(io, "ideal in $(I.parent.R), generated by $(I.gens)\n")
end


######################################################################
mutable struct ModField{T <: FieldElem}
  ring::Field
  dim::Int

  function ModField{T}(R::Ring, n::Int)
    r = new()
    r.ring = R
    r.dim = n
    return r
  end
end

function show(io::IO, M::ModField)
  println(io, "free module of rank $(M.dim) over $(M.ring)\n")
end

mutable struct ModFieldElem{T <: FieldElem}
  coeff::Array{T, 1} # TODO: figure out how to declare a matrix...
  parent::ModField{T}

  function ModFieldElem{T}(M::ModField, c::Array{T, 1})
    r = new()
    r.parent = M
    r.coeff = c
    return r
  end
end

function show(io::IO, x::ModFieldElem)
  println(io, x)
end


mutable struct ModFieldToModFieldMor <: Map{ModField, ModField}
  header::MapHeader
  map::Matrix

  function ModFieldToModFieldMor(M::ModField, N::ModField, map::Matrix)
    r = new()
    r.header = MapHeader(M, N, im, pre)
    r.map = map
    return r
  end
end


#############################################################
# same again for Euc, ModDed
# and
# Subquo....
