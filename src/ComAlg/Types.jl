import Base: show

export vector_space, ModField, ModFieldElem, ModFieldToModFieldMor, free_module


mutable struct MPolyIdlSet{T <: MPolyElem{ <: RingElem}}
  R::MPolyRing{T}
  function MPolyIdlSet{T}(R::MPolyRing{T}) where T
    return new(R)
  end
end

function show(io::IO, I::MPolyIdlSet)
  println(io, "Set of ideals of $(I.R)\n")
end

mutable struct MPolyIdl{T <: MPolyElem{ <:RingElem}}
  gens::Array{T, 1} # initial generators
  parent::MPolyRing{T}
  std::Array{T, 1} # a Groebner basis is known/ computed
  ishomogenous::Bool
  hilbert::Any #PowerSeries

  function MPolyIdl{T}(gens::Array{T, 1}) where T
    r = new()
    r.gens = gens
    return r
  end
end

function show(io::IO, I::MPolyIdl)
  println(io, "ideal in $(I.parent.R), generated by $(I.gens)\n")
end


######################################################################
mutable struct ModField{T <: Nemo.FieldElem}
  ring::Nemo.Field
  dim::Int

  function ModField{T}(R, n::Int) where T <: Nemo.FieldElem
    r = new()
    r.ring = R
    r.dim = n
    return r
  end
end


function vector_space(K::Nemo.Field, n::Int, t::Type=elem_type(K))
  return ModField{t}(K, n)
end

function free_module(K::Nemo.Field, n::Int)
  return vector_space(K, n)
end

function show{T}(io::IO, M::ModField{T})
  print(io, "free module of rank $(M.dim) over $(M.ring)\n")
end

mutable struct ModFieldElem{T <: Nemo.FieldElem}
  coeff::Array{T, 1} # TODO: figure out how to declare a matrix...
  parent::ModField{T}

  function ModFieldElem{T}(M::ModField{T}, c::Array{T, 1}) where T <: Nemo.FieldElem
    r = new()
    r.parent = M
    r.coeff = c
    return r
  end
end

function (V::ModField{T})(c::Array{T, 1}) where T <: Nemo.FieldElem
  v = ModFieldElem{T}(V, c)
end

function show(io::IO, x::ModFieldElem)
  print(io, "vector: ", x.coeff)
end

mutable struct ModFieldToModFieldMor{T <: Nemo.FieldElem} <: Map{ModField, ModField}
  header::Hecke.MapHeader
  map::MatElem{T}

  function ModFieldToModFieldMor{T}(M::ModField{T}, N::ModField{T}, map::MatElem{T}) where T
    r = new()
    function image(x::ModFieldElem)
      return N(map*Nemo.matrix(coeff_field(M), dim(M), 1, x.coeff))
    end
    r.header = Hecke.MapHeader(M, N, image)
    r.map = map
    return r
  end
end


#############################################################
# same again for Euc, ModDed
# and
# Subquo....
